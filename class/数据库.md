# 绪论
## 数据是数据库存储的基本对象
## 数据库是长期存储在计算机内，有组织的，可共享的大量数据集合
## 数据库关系系统
功能：
1.数据定义
2.数据组织，储存和管理
3.数据操纵
4.数据库的事物管理和运行维护
5.数据库的建立和维护功能（实用功能）
6.DBMS与其他软件通信，异构数据库之间的访问
## 数据库系统
数据库，数据库关系系统，用户/管理员，应用系统
特点：
1.数据结构化，
    数据内部结构化，整体结构化（主码和外码）
2.数据的共享性高，冗余度低（保证copy精度），易扩充
3.数据独立性高
    物理独立性（物理储存和应用程序之间的关系）
    逻辑独立性（逻辑结构和应用程序的关系）
    数据独立性(由DBMS的二级映像功能来保证)
4.数据由DBMS统一管理和控制
    数据安全性保护
    数据完整性检查
    并发控制
    数据库恢复
## 两大数据模型
现实世界，信息世界，机器世界
### 概念模型
独立于具体的机器和DBMS
### 逻辑模型与物理模型
常见逻辑模型：
1. 非关系型模型：网状，层次
2. 关系型模型
3. 面向对象模型
4. 半结构化数据模型
## 数据模型的组成要素
数据结构，数据操作，完整性约束条件

# 关系数据库
## 基本概念
关系（Relation）：一个关系对应通常说的一张表
元组（Tuple）：表中的一行即为一个元组
属性（Attribute）：表中的一列及为一个属性，给每一个属性起一个名称即属性名
主码（Key）：表中的某个属性组，它可以唯一确定一个元组
候选码：一个属性组能标识一个元组，称该属性组为候选码
全码：所有属性组是候选码
主属性：候选码的诸属性称为主属性，其他为非主属性或非码属性
域（Domain）：属性的取值范围
分量：元组中的一个属性值
关系模式：
    对关系的描述
    关系名（属性1，属性2，…，属性n）
笛卡尔积：
    一种集合运算，有基数的概念。
## 关系数据库三种模式
外模式 模式 内模式  
![20220526154741](https://raw.githubusercontent.com/GWrety/Ima/master/images/20220526154741.png)
## 关系模式
    关系模式是型，关系是值
    关系模式是对关系的抽象表示
## 关系操作
### 常用关系操作：
	选择，投影，并，差，笛卡尔积是5种基本操作
    除，交，连接可以由上述五种表示
### 关系数据库语言的分类
    关系代数语言    
    关系演算语言
    SQL
关系数据语言特点：
    高度非过程化
    完备的表达能力
    能够嵌入高级语言中
## 关系完整性
### 实体完整性
### 参照完整性
### 用户定义完整性
## 关系代数
### 传统集合运算
1. 并
2. 差
3. 交
4. 笛卡尔积
### 专门的关系运算
1. 选择
2. 投影
3. 连接（外连接）
    等值连接，自然连接
4. 除

# SQL
## 特点
1. 综合统一
集数据定义语言（DDL）、数据操纵语言（DML）、数据控制语言（DCL）功能于一体。
    可以独立完成数据库生命周期中的全部活动：
    定义关系模式，插入数据，建立数据库；
    对数据库中的数据进行查询和更新；
    数据库重构和维护
    数据库安全性、完整性控制等
2.高度非过程化
    只需要描述做什么，无需了解存取路径
3.面向集合的操作方式
    操作的对象都是集合
4.以同一种语法结构提供多种使用方式
    既能独立的用于联机交互
    也能嵌入到高级语言程序中
5.简洁易学，易学易用
## 数据定义
![20220526164154](https://raw.githubusercontent.com/GWrety/Ima/master/images/20220526164154.png)
### 模式
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>
DROP SCHEMA <模式名> <CASCADE|RESTRICT>
### 表
#### 定义
CREATE TABLE <表名>
      （<列名> <数据类型>[ <列级完整性约束条件> ]
      [，<列名> <数据类型>[ <列级完整性约束条件>] ] …
      [，<表级完整性约束条件> ] ）；
#### 修改
ALTER TABLE <表名>
[ ADD <新列名> <数据类型> [ 完整性约束 ] ]
[ DROP <完整性约束名> ]
[ ALTER COLUMN<列名> <数据类型> ]；
#### 删除
DROP TABLE <表名><RESTRICT|CASCADE>；
### 索引
#### 建立
CREATE [UNIQUE] [CLUSTER] INDEX <索引名> 
ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…)；
#### 删除
DROP INDEX <索引名>；

## 数据查询
### 单表查询
SELECT [ALL|DISTINCT] <目标列表达式>
[，<目标列表达式>] …
FROM <表名或视图名>[， <表名或视图名> ] …
[ WHERE <条件表达式> ]
[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
[ ORDER BY <列名2> [ ASC|DESC ] ]；

#### 消除重复行
DISTINCT/ALL
#### 确定范围
（NOT）BETWEEN ...AND...
#### 确定集合
IN/NOT IN
#### 字符匹配
LIKE/NOT LIKE
#### 转义
ESCAPE '＼' 表示“ ＼” 为换码字符；
#### 是否空值
IS NULL/ IS NOT NULL
#### 排序
ORDER BY ASC/DESC
#### 聚集
COUNT SUM AVG MAX MIN

#### 查询语句执行顺序
先 form 再 where 筛选出一个表
然后 group by 分成好几组
然后 having 丢弃不要的组
最后select  在分组上应用聚集函数

### 嵌套查询
IN
ANY/ALL
（NOT）EXISTS

### 集合查询
并操作UNION
交操作INTERSECT
差操作EXCEPT

### 除法写法
R（X，Y） S（Y）
R%S
select distinct R.X from R R1
where not exists
( 
    select S.Y from S
    where not exists
    ( 
        select * from R R2
        where R2.X=R1.X and R2.Y=S.Y 
    ) 
)

## 数据更新
### 插入元组
INSERT
INTO <表名> [(<属性列1>[，<属性列2 >…)]
VALUES (<常量1> [，<常量2>]  … )
### 插入子查询结果
INSERT 
    INTO <表名>  [(<属性列1> [，<属性列2>…  )]
    子查询；

### 修改数据
UPDATE  <表名>
SET  <列名>=<表达式>[，<列名>=<表达式>]…
[WHERE <条件>]；

### 删除数据
DELETE
FROM   <表名>
[WHERE <条件>]；

## 视图

### 定义视图
CREATE  VIEW  <视图名>  [(<列名>  [，<列名>]…)]
AS  <子查询>
[WITH  CHECK  OPTION]；

### 删除视图
DROP  VIEW  <视图名>；

### 查询视图
与基本表相同

### 更新视图
更新视图会转换为基本表的更新
数据库对视图更新的限制：
    若视图是由两个以上基本表导出的，则此视图不允许更新。
    若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。
    若视图的字段来自集函数，则此视图不允许更新。
    若视图定义中含有GROUP BY子句，则此视图不允许更新。
    若视图定义中含有DISTINCT短语，则此视图不允许更新。
    若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。
    一个不允许更新的视图上定义的视图也不允许更新

### 视图作用
1.化简用户操作
2.能使用户以不同的方式看待同一数据
3.对重构数据库提供了一定程度的逻辑独立性
4.能够对机密数据提供安全保护
5.利用视图可以更清晰的表达查询

# 数据库安全
防止非法用户的数据访问
防止合法用户的非法数据访问

## 三类计算机系统安全性问题
    技术安全类
    管理安全类
    政策法律类
## TCSEC/TDI安全级划分
从四个方面：安全策略，责任，保证，文档划分安全级别
D
C1 自主取控制DAC
C2 审计
B1 强制存取控制MAC
B2以上的系统还处于理论阶段

## 数据库安全性控制

### 用户
#### 授予权限
GRANT <权限>[,<权限>]... 
       [ON <对象类型> <对象名>]
       TO <用户>[,<用户>]...
       [WITH GRANT OPTION];
#### 收回权限
REVOKE <权限>[,<权限>]... 
      [ON <对象类型> <对象名>]
      FROM <用户>[,<用户>]...;

### 角色
角色是权力的集合
#### 创建角色
 CREATE  ROLE  <角色名> 
#### 给角色授权
GRANT  <权限>［，<权限>］… 
 ON <对象类型>对象名  
 TO <角色>［，<角色>］…
#### 将角色赋予用户
 GRANT  <角色1>［，<角色2>］…
 TO  <角色3>［，<用户1>］… 
［WITH ADMIN OPTION］ 
#### 角色权限收回
REVOKE <权限>［，<权限>］…
 ON <对象类型> <对象名>
 FROM <角色>［，<角色>］…

### 强制存取控制
许可证级别，密级
规则：
- 高级别的人可以读取
- 低级别的人可以写入
修正规则：
用户可以为写入的数据对象赋予高于=自己的许可证级别的密级

## 审计
AUDIT语句：设置审计功能 
NOAUDIT语句：取消审计功能 

## 数据加密
## 统计数据库安全
规则1：任何查询至少要涉及N(N足够大)个以上的记录
规则2：任意两个查询的相交数据项不能超过M个
规则3：任一用户的查询次数不能超过1+(N-2)/M

# 数据库完整性
## 实体完整性
主码：CREATE  TABLE中用PRIMARY KEY定义
## 参照完整性
外码；在CREATE  TABLE中用FOREIGN KEY短语定义哪些列为外码。用REFERENCES短语指明这些外码参照哪些表的主码 
## 完整性约束
CONSTRAINT <完整性约束条件名>
PRIMARY KEY短语|FOREIGN KEY短语|CHECK短语］

## 触发器
### 定义
CREATE TRIGGER <触发器名>  
    {BEFORE | AFTER} <触发事件> ON <表名>
    FOR EACH  {ROW | STATEMENT}
    ［WHEN <触发条件>］
    <触发动作体>

### 删除
DROP TRIGGER <触发器名> ON <表名>;

# 关系数据库理论
## 函数依赖
### 平凡函数依赖
X->y，y属于x
### 非平凡函数依赖
X->y，y不属于x
### 完全函数依赖
x——>y,且x的真子集都无法确定y
### 部分函数依赖
非完全函数依赖
### 传递函数依赖
在关系模式R(U)中，如果X→Y，Y→Z，且Y不属于X，Y不能确定X，则称Z传递函数依赖于X。
## 码
### 候选码
一个属性组能确定一个元组，则这个属性组称为候选码
### 主码
若关系模式中有多个候选码，则选定一个为主码
### 超码
候选码是最小的超码，
## 范式
### 1NF
所有属性不可再分（是关系数据库都满足）
### 2NF
消除函数依赖
### 3NF
消除传递依赖
### BCNF
所有的依赖关系，左侧都有候选码
### 4NF
传递依赖，都有候选码
## 数据依赖的公理系统

### Armstrong公理系统
1. 自反律 集合能推出子集
2. 增广律 函数依赖两边可以同时加其他属性
3. 传递律 传递依赖
### 闭包
函数依赖的闭包
属性集的闭包

## 模式分解
### 无损连接性
即分解后的自然连接结果与分解前相等
### 保持函数依赖
原来干系模式的函数依赖一定分解到某个子关系中

### 判断一个分解是否无损
列表，逐个依赖渲染。看能否有一行全部确定

# 数据库设计
## 需求分析
### 数据字典
数据项
数据结构
数据流
数据存储
处理过程
## 概念结构
E-R图
消除冗余：
将数据定义在视图中
最小依赖集
分E-R图—————和并，清除冲突—->初步E-R图————清楚不必要冗余->基本E-R图
## 逻辑结构
一个实体转换一个关系模式
1：n有两种选择
三个或三个以上实体间的一个多元联系转换为一个关系模式
相同码的关系模式可以合并

# 查询优化
查询分析，查询检查，查询优化，查询执行

## 代数优化
### 关系代数优化
关系代数等价变换
### 查询树的启发式优化

## 物理优化
### 基于存取路径的选择优化
### 基于代价的优化

# 恢复
## 事物
事物是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是个不可分割的工作单位。
### 事物特性
原子性，一致性，隔离性，持续性

## 故障
### 事物故障
### 系统故障
### 介质故障

## 恢复
### 事物故障
撤销操作undo
### 系统故障    
undo  redo重做 
### 介质故障
重写装入

## 检查点恢复策略
## 数据库镜像

# 并发
## 并发带来的数据不一致性
丢失修改  写的操作被覆盖
不可重复读  读完，再读不一样
读脏数据    修改，写回。 但另一个读完后，他回滚了

## 封锁
排他锁X 共享锁S
### 一级封锁协议
修改前X，事物结束后释放
不丢失修改
### 二级封锁协议
1级+读前+S，读后释放
防止 丢失修改和读脏数据
### 三级封锁协议
1级+读前S，事物后释放
均可避免

## 冲突可串行化调度

## 两段锁协议
### 第一阶段
获得锁
### 第二阶段
释放锁
这个是对于每一个事物来说的
结论：所有遵守两段锁协议的事物，其执行结果一定是正确的

## 死锁
### 预防
一次封锁法
顺序封锁法
（不好用）
### 诊断与接触
超市法
等待图法

## 封锁的粒度
封锁对象的大小称为封锁的粒度

### 多粒度封锁

### 意向锁

