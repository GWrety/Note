# 软件工程概述
## 什么是软件工程
>是把系统的，有序的，可量化的方法应用到软件的开发，运营和维护上的过程  
##  软件工程包括那些领域
>软件需求分析，软件设计，软件构建，软件测试，软件维护。
## 为什么要搞软件工程
>    - 因为需求复杂（要满足不同用户的多种需求，并提供长期服务）
>    - 因为系统复杂
>    - 因为人的生命财产依赖于软件  

*Program = data structure + algorithm
Software = Program + Software Engineering
Software Company = Software + Business Model*
## 软件的特性
> - 复杂性（软件是人类创造最复杂的系统类型） 
> - 不可见性（看不到软件如何在用户机上被执行，且只能捕捉错误出行的一丝痕迹）
> - 易变性（看上去很容易修改，人们总是期待1.让软件做新的事。2.让软件适应新的硬件。但正确的修改软件不容易）
> - 服从性（软件不能独立存在，服从硬件，系统中其他部分，服从用户，行业要求（银行利率））
> - 非连续性（输入的改变和输出的改变差别很大）
> - 没有银弹（有许多新特性，但都无关紧要（新编程语言，开发平台，软件开发流程，ai-coding，github），他们无法改变软件工程的根本难度）  
## 软件质量
>   不合格的软件带来的伤害是巨大的（people and money）
>   bug or feature？取决于你看的角度 
## 软件工程和计算机科学的不同
>计算机科学总与理论有关，软件工程总与人有关
![20220424192806](https://raw.githubusercontent.com/GWrety/Ima/master/images/20220424192806.png)  

![20220424194024](https://raw.githubusercontent.com/GWrety/Ima/master/images/20220424194024.png)

# 个人技术
## 单元测试
对软件基本组成单元进行的测试，其测试对象式软件设计的最小单元（模块或类）
1. 行覆盖（又叫语句覆盖）就是通过设计一定量的测试用例，保证被测试的方法每一行代码都会被执行一遍。
2. 判定覆盖（判定覆盖的含义就是代码里每一个判定都要走一次true，一次false）
3. 条件覆盖（条件覆盖和判定覆盖类似，不过判定覆盖着眼于整个判定语句，而条件覆盖则着眼于某个判断条件。条件之间可以搭配走）
4. 路径覆盖（覆盖所有可能执行的路径，所有t/f组合）
>弊端： 无法测试没写代码 效能问题，线程问题
## 回归测试
指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误

# 个人软件流程
## PSP 2.1（个人软件工程）
![20220424204308](https://raw.githubusercontent.com/GWrety/Ima/master/images/20220424204308.png)  

1. 优点
   - 不依赖于某一种语言，着眼于开发流程
   - 不依赖于考试，依赖工程师自己收集数据，然后分析，提高
2. 缺点
   - 在小型的创业团队很难找到高质量需求分析文档，导致后续活动混乱
   - 依赖于数据 需要手动记录，且易丢失
   - 难以记录工作量
   - 没衡量最终的结果（没客户）
## 软件工程师的误区
1. 分析麻痹（100%把握再出手）
2. 依赖链条过长（不分主次，想解决所有问题）
3. 过早优化
4. 过早泛化

# 双人合作
## 代码复审
1. 自我复审（开发者过于自信，可能无效）
2. 同伴复审（简便易行）
3. 团队复审（覆盖率高，适合关键代码和不再更新的代码）
## 复审代码核查表-概要
1. 代码符合需求和规格说明么？ 
2. 代码设计是否考虑周全？
3. 代码可读性如何？ 
4. 代码容易维护么？
5. 代码的每一行都执行并检查过了吗？  
## 复审者的更高要求
1. “这么修改之后，有没有别的功能会受影响?”
2. “项目中还有别的地方需要类似的修改么?”
3. “有没有留下足够的说明，让将来维护代码时不会出现问题？对于这样的修改，有没有别的成员需要告知?”
4. “导致问题的根本原因是什么？我们以后如何能自动避免这样的情况再次出现?”
## 结对编程

**好处**
1. 提高设计质量 避免愚蠢bug
2. 减低成本 分享知识，降低debug时间
3. 提高解决问题的信心
4. 提高士气 工作被认可
5. 减轻风险 降低成员离开的负面影响
6. 提高效率 不好意思摸鱼  

**坏处**
1. 工作方式不同
2. 让人感觉威胁
3. 时间可能花在培训上
4. 对个人情绪和自尊影响

**合适的场景**
1. 降低容易犯的错误 新手 + 新手， 或者双方各有明显弱点
2. 探索一个新的领域
3. 传播知识和技能  老手+新手

**不适合的场景**
1. 需要深入地研究的项目，需要一个人长时间的独立钻研；
2. 在做后期维护的时候，如果维护的技术含量不高，只需要做有效的复审即可；
3. 如果验证测试需要运行很长时间，那么两个人在那里等待结果是有点浪费时间；
4. 如果团队的人员要在多个项目中工作，不能充分保证足够的结对编程时间，那么成员要经常处于等待的状态，反而影响效率；

